// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advect
#pragma kernel Force
#pragma kernel Diffuse2D
#pragma kernel Diffuse1D
#pragma kernel ProjectSetup
#pragma kernel Project
#pragma kernel Curl
#pragma kernel Vorticity

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> testInput;

float DELTA_T;
float worldTime;

// Advect Velovity (Self)
RWTexture2D<float2> VelSrc;
RWTexture2D<float2> VelDest;

// Advect Velocity (Output)
Texture2D<float2> AdvectOutSrc;
RWTexture2D<float2> AdvectOutDest;

// Diffuse
float DIFF_A;
float DIFF_B;

// --Diffuse 1D
Texture2D<float> Diff1DSrc;
Texture2D<float> Diff1DOrigSrc;
RWTexture2D<float> Diff1DDest;

// --Diffuse 2D
Texture2D<float2> Diff2DSrc;
Texture2D<float2> Diff2DOrigSrc;
RWTexture2D<float2> Diff2DDest;

// Force
float FORCE_DECAY;
float FORCE_AMPLITUDE;
float2 forcePos;
float2 forceVector;

// Project
RWTexture2D<float> VelDivergence;
RWTexture2D<float> PressureSrc;
RWTexture2D<float> PressureDest;

// Vortex
RWTexture2D<float> VelCurl;
float CURL;

float boundaryMode = -1;

[numthreads(8,8,1)]
void Advect (uint2 id : SV_DispatchThreadID)
{
    uint2 outputDim;
    AdvectOutDest.GetDimensions(outputDim.x, outputDim.y);

    // Normalize
    float2 currentUV = (id + 0.5) / outputDim;
    float2 displacement = VelSrc[id] * float2((float)outputDim.y/outputDim.x, 1) * DELTA_T;

    AdvectOutDest[id] = VelSrc[(uint2)((currentUV - displacement) * outputDim)];
}

[numthreads(8,8,1)]
void Force (uint2 id : SV_DispatchThreadID)
{
    uint2 dim;
    AdvectOutDest.GetDimensions(dim.x, dim.y);

    float2 pos = (id + 0.5)/dim - 0.5;
    float amp = exp(-FORCE_DECAY * distance(forcePos, pos)) * FORCE_AMPLITUDE;

    AdvectOutDest[id] = AdvectOutSrc[id] + forceVector * amp;
}

[numthreads(8,8,1)]
void Diffuse2D (uint2 id : SV_DispatchThreadID)
{
    Diff2DDest[id] = (
        Diff2DSrc[id - int2(1, 0)] + 
        Diff2DSrc[id + int2(1, 0)] + 
        Diff2DSrc[id - int2(0, 1)] +
        Diff2DSrc[id + int2(0, 1)] +
        Diff2DOrigSrc[id] * DIFF_A) / DIFF_B;
}

[numthreads(8,8,1)]
void Diffuse1D (uint2 id : SV_DispatchThreadID)
{
    Diff1DDest[id] = (
        Diff1DSrc[id - int2(1, 0)] + 
        Diff1DSrc[id + int2(1, 0)] + 
        Diff1DSrc[id - int2(0, 1)] +
        Diff1DSrc[id + int2(0, 1)] +
        Diff1DOrigSrc[id] * DIFF_A) / DIFF_B;
}

[numthreads(8,8,1)]
void ProjectSetup (uint2 id : SV_DispatchThreadID)
{
    uint2 outputDim;
    AdvectOutSrc.GetDimensions(outputDim.x, outputDim.y);

    VelDivergence[id] = (
        AdvectOutSrc[id + int2(1, 0)].x - AdvectOutSrc[id - int2(1, 0)].x +
        AdvectOutSrc[id + int2(0, 1)].y - AdvectOutSrc[id - int2(0, 1)].y
    ) * outputDim.y /2;

    PressureSrc[id] = 0;
}

[numthreads(8,8,1)]
void Project (uint2 id : SV_DispatchThreadID)
{
    uint2 dim;
    AdvectOutSrc.GetDimensions(dim.x, dim.y);

    if (any(id == 0) || any(id == dim - 1))
        return;
    
    float PLeft = PressureSrc[max(id - int2(1, 0), 1)];
    float PRight = PressureSrc[min(id + int2(1, 0), dim - 2)];
    float PUp = PressureSrc[max(id - int2(0, 1), 1)];
    float PDown = PressureSrc[min(id + int2(0, 1), dim - 2)];

    float2 updatedVel = AdvectOutSrc[id] - float2(PRight - PLeft, PDown - PUp) * dim.y /2;
    VelDest[id] = updatedVel;

    float2 boundaryVel = updatedVel * boundaryMode;

    // Set Boundaries
    if (id.x == 1) {
        VelDest[int2(0, id.y)] = boundaryVel;
    } else if (id.x == dim.x - 2) {
        VelDest[int2(dim.x - 1, id.y)] = boundaryVel;
    }

    if (id.y == 1) {
        VelDest[int2(id.x, 0)] = boundaryVel;
    } else if (id.y == dim.y - 2) {
        VelDest[int2(id.x, dim.y - 1)] = boundaryVel;
    }

    // Set Corners
    if (id.x == 1 && id.y == 1)
        VelDest[int2(0,0)] = (VelDest[int2(1,0)] + VelDest[int2(0,1)]) * 0.5;
    else if (id.x == 1 && id.y == dim.y - 2)
        VelDest[int2(0, dim.y - 1)] = (VelDest[int2(0,dim.y - 2)] + VelDest[int2(1,dim.y - 1)]) * 0.5;
    else if (id.x == dim.x - 2 && id.y == 1)
        VelDest[int2(dim.x - 1, 0)] = (VelDest[int2(dim.x - 2, 0)] + VelDest[int2(dim.x - 1, 1)]) * 0.5;
    else if (id.x == dim.x - 2 && id.y == dim.y -2)
        VelDest[int2(dim.x - 1, dim.y - 1)] = (VelDest[int2(dim.x - 2, dim.y - 1)] + VelDest[int2(dim.x - 1, dim.y - 2)]) * 0.5;
}

[numthreads(8,8,1)]
void Curl (uint2 id : SV_DispatchThreadID)
{
    VelCurl[id] = (
        (AdvectOutSrc[id + int2(1, 0)].y - AdvectOutSrc[id - int2(1, 0)].y) - 
        (AdvectOutSrc[id + int2(0, 1)].x - AdvectOutSrc[id - int2(0, 1)].x)
    ) / 2.0;
}

[numthreads(8,8,1)]
void Vorticity (uint2 id : SV_DispatchThreadID)
{
    uint2 outputDim;
    AdvectOutDest.GetDimensions(outputDim.x, outputDim.y);

    float CLeft = VelCurl[id - int2(1, 0)];
    float CRight = VelCurl[id + int2(1, 0)];
    float CUp = VelCurl[id - int2(0, 1)];
    float CDown = VelCurl[id + int2(0, 1)];
    float CurlVal = VelCurl[id];

    float2 force = float2(abs(CDown) - abs(CUp), -(abs(CRight) - abs(CLeft))); // second term inverse?
    float forceLen = length(force);
    force = (forceLen == 0 ? float2(0,0) : (force / forceLen));
    force *= (CURL * CurlVal);

    AdvectOutDest[id] = AdvectOutSrc[id] + force * DELTA_T;
}